# OPERACIONES ELEMENTALES
El orden de complejidad es una medida matem치tica que describe el rendimiento de un algoritmo en funci칩n del tama침o de la entrada (generalmente denotada como $$\( n \)$$). Se utiliza para analizar y comparar algoritmos, centr치ndose en el tiempo de ejecuci칩n o en el uso de recursos (como memoria) a medida que $$\( n \)$$ crece.

Entonces, el 칩rden de complejidad de una acci칩n se calcula as칤:
- **Operaciones b치sicas:**
  + asignaci칩n (`:=`), suma (`+`), resta (`-`), multiplicaci칩n (`*`), divisi칩n (`/`, `DIV`), menor (`<`), mayor(`>`), igual(`=`): valen **1 OE**.
  + igual o menor que (`<=`), igual o mayor que (`>=`), distinto (`<>`): valen **2 OE**.
- **Sub칤ndices de un arreglo:** valen **1 OE**, por lo que dependiendo la cantidad de sub칤ndices se incrementa el valor. Para 3 sub칤ndices, el valor es de 3 OE.
- **Operaciones de entrada/salida:** se consideran una unidad de tiempo o una constante (1 OE). Sin embargo, en la pr치ctica, estas operaciones pueden tener una mayor complejidad dependiendo del sistema, pero para el an치lisis de orden de complejidad se suelen tratar como 1 OE.
- **Estructuras de Control Iterativas:** se analizan sumando el n칰mero de veces que se ejecuta cada operaci칩n dentro del bucle: $$T_{\text{total}} = T(c) + (\text{n춿 iteraciones}) \times (T(S) + T(c))$$
  - **Manejado por contador:** Se pueden expresar como un sumatorio, utilizando los l칤mites del ciclo. Por ejemplo, para un ciclo de argumento ```(n:= 1 hasta 10, 1)``` tiene un total de 10 OE (si realiza solamente acciones de 1 OE).
  - **Pre-Test & Pos-Test:** el an치lisis de la condici칩n del bucle es $$O(n)$$ en ambos casos porque la condici칩n se eval칰a una cantidad lineal de veces con respecto al n칰mero de iteraciones del bucle.
- **Estructuras de Control Condicionales:** los condicionales deben analizarse en funci칩n del mejor caso y el peor caso: $$T_{\text{total}} = T(C) + \max(T(SA), T(SB),...,T(SN)$$
  - **Mejor caso:** cuando la condici칩n se eval칰a como verdadera.
  - **Peor caso:** cuando la condici칩n se eval칰a como falsa.
- **Llamadas a Procedimientos:** cuando un algoritmo incluye llamadas a procedimientos, se debe calcular el 0E de la llamada y sumar los costos de las operaciones dentro de dicho procedimiento.
 
> [!IMPORTANT]
> La complejidad total de una estructura de control iterativa o condicional, tambi칠n depende de lo que haga el c칩digo dentro del bucle, pero si solo consideramos la evaluaci칩n de la condici칩n, es $$O(n)$$.

### EJEMPLO
Es un algoritmo de [b칰squeda binaria](../Estructuras%20de%20Datos/Arreglos/2.%20Metodos%20de%20Busqueda.md#b칰squeda-binariadicot칩mica) que originalmente estaba en pascal. De todos modos, el concepto y fin del ejemplo se mantiene.
```groovy
Funcion Algoritmo2(a: Array [1...n] de entero; c, n: entero): entero ES
Ambiente
  inf, sup, i: entero
Proceso
  inf:= 1  // 1 OE
  sup:= n  // 1 OE
  Mientras ((sup >= inf) y (a[i] <> c)) Hacer  // 6 OE
    i:= (inf + sup) DIV 2  // 3 OE
    Si (a[i] < c) Entonces   // 2 OE
      inf:= i + 1  // 2 OE
    Sino
      Si (a[i] > c) Entonces  // 2 OE
        sup:= i - 1  // 2 OE
      FinSi
    FinSi
    Si (a[i] = c) Entonces  // 2 OE
      Algoritmo2:= i;  // 1 OE
    Sino
      Escribir("NO EXISTE")  // 1 OE
    FinSi
  FinMientras
FinFuncion
```
Ahora, si analizamos bien los ciclos y condicionales (peor caso):

$$
2 + (\sum_{i=0}^{n} (6+9)n) + 2 + 3
$$

$$
2 + 15n + 5
$$

$$
15n + 7
$$

El algoritmo tiene complejidad [logar칤tmica](#log), lo que significa que su tiempo de ejecuci칩n crece lentamente a medida que 洧녵 aumenta. 
1. En la primera iteraci칩n, busca en 洧녵 elementos.
2. En la segunda, en 洧녵/2.
3. En la tercera, en 洧녵/4.

Y as칤 sucesivamente, hasta llegar o no al elemento.

## PRINCIPIO DE INVARIANZA
Este principio indica que para dos implementaciones distintas de un mismo algoritmo (I1 e I2) con tiempos de ejecuci칩n $$\( T_1(n) \)$$ y $$\( T_2(n) \)$$, existe una constante $$\( c > 0 \)$$ y un valor $$\( n_0 \)$$ tal que para todo $$\( n \geq n_0 \)$$, se cumple que:

$$\
T_1(n) \leq c \cdot T_2(n)
\$$

El principio demuestra que, cuando se compara el rendimiento de diferentes implementaciones de un algoritmo, la diferencia en el tiempo de ejecuci칩n no es significativa en t칠rminos de la complejidad del algoritmo. En otras palabras, la naturaleza del algoritmo es m치s importante que las optimizaciones espec칤ficas de una implementaci칩n, ya que estas optimizaciones solo afectan el tiempo de ejecuci칩n por un factor constante. Esto significa que el tiempo de ejecuci칩n de dos implementaciones distintas de un algoritmo dado no va a diferir m치s que en una constante multiplicativa.

> [!IMPORTANT]
> No solo el tama침o $$n$$ importa, sino tambi칠n c칩mo est치n organizados o distribuidos esos datos en la entrada. La complejidad de un algoritmo puede variar significativamente dependiendo de la distribuci칩n de los elementos en el caso medio o en el peor caso, lo que puede hacer que su tiempo de ejecuci칩n sea m치s o menos eficiente en la pr치ctica.

## 칍RDENES DE COMPLEJIDAD
El **comportamiento asint칩tico** estudia el rendimiento de un algoritmo cuando el tama침o de la entrada $$\( n \)$$ tiende a infinito. Las funciones que describen el uso de recursos se agrupan en familias de complejidad seg칰n su crecimiento asint칩tico, representadas con la notaci칩n $$O(f(n))$$. Resumiendo, una familia de funciones que comparten un mismo comportamiento asint칩tico ser치 llamada un Orden de Complejidad.
Algunos 칩rdenes de complejidad com칰nes son:
- **$$O(1)$$:** constante; el algoritmo es independiente de $$n$$. Se presenta en instrucciones que no tienen repeticiones, por ejemplo.
- **$$O(\log n)$$:** <span id=log> logar칤tmica </span>; crece lentamente, eficiente para grandes $$n$$, como pasa en la [b칰squeda binaria](../Estructuras%20de%20Datos/Arreglos/2.%20Metodos%20de%20Busqueda.md#b칰squeda-binariadicot칩mica). 
- **$$O(n)$$:** lineal; el tiempo de ejecuci칩n crece proporcionalmente con $$n$$. La [b칰squeda secuencial](../Estructuras%20de%20Datos/Arreglos/2.%20Metodos%20de%20Busqueda.md#b%C3%BAsqueda-lineal-purasimple) es un ejemplo.
- **$$O(n\log n)$$:** cuasi-lineal; com칰n en algoritmos de ordenamiento eficientes. Aparece en algunos m칠todos de ordenamiento, como el [Quick-Sort](../Estructuras%20de%20Datos/Arreglos/1.%20Metodos%20de%20Ordenamiento.md#quicksortintercambio-avanzado).
- **$$O(n^2)$$:** cuadr치tica; crece r치pidamente, menos eficiente para grandes $$n$$. Aparece en ciclos doblemente anidados, como en el de [ordenamiento por selecci칩n](../Estructuras%20de%20Datos/Arreglos/1.%20Metodos%20de%20Ordenamiento.md#selecci%C3%B3n-directa).
- **$$O(n^3)$$:** c칰bica; com칰n en algoritmos de procesamiento de matrices.
- **$$O(n^a)$$:** polin칩mica; el rendimiento empeora con potencias m치s altas.
- **$$O(2^n)$$:** exponencial; ineficiente, crece muy r치pido.
- **$$O(n!)$$:** factorial; altamente ineficiente, solo para casos muy espec칤ficos y de baja $$n$$. Por ejemplo, un algoritmo que busque todas las permutaciones dado un conjunto de n칰meros.

El orden ideal es que sea constante, lo cual es raro, por lo que el lineal es el objetivo m치s com칰n.
